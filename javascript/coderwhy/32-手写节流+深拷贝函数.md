<!--
 * @Author: your name
 * @Date: 2022-02-18 09:40:46
 * @LastEditTime: 2022-02-18 15:06:59
 * @LastEditors: Please set LastEditors
 * @Description: 手写节流 + 深拷贝函数
 * @FilePath: \forGreaterGood\javascript\coderwhy\32-手写节流+深拷贝函数.md
-->

# 手写节流 + 深拷贝函数

## 一、节流

### 1.1 基本功能

```js
function throttle(fn, interval) {
  let lastTime = 0;

  function _throttle() {
    const nowTime = new Date().getTime();
    const remainTime = interval - (nowTime - lastTime);
    if (remainTime <= 0) {
      fn();
      lastTime = nowTime;
    }
  }

  return _throttle;
}
```

### 1.2 是否立即执行和最后一次

```js
function throttle(fn, interval, options = { leading: true, trailing: false }) {
  const { leading, training } = options;
  let lastTime = 0;
  let timer = undefined;

  function _throttle() {
    const nowTime = new Date().getTime();
    if (!lastTime && !leading) lastTime = nowTime;
    const remainTime = interval - (nowTime - lastTime);
    if (remainTime <= 0) {
      timer && clearTimeout(timer);
      timer = undefined;
      fn();
      lastTime = nowTime;
      return;
    }

    if (trailing && !timer) {
      timer = setTimeout(() => {
        fn();
        timer = undefined;
        lastTime = !leading ? 0 : new Date().getTime();
      }, remainTime);
    }
  }

  return _throttle;
}
```

### 1.3 this 和 参数

```js
function throttle(fn, interval, options = { leading: true, trailing: false }) {
  const { leading, training } = options;
  let lastTime = 0;
  let timer = undefined;

  function _throttle(...args) {
    const nowTime = new Date().getTime();
    if (!lastTime && !leading) lastTime = nowTime;
    const remainTime = interval - (nowTime - lastTime);
    if (remainTime <= 0) {
      timer && clearTimeout(timer);
      timer = undefined;
      fn.apply(this, args);
      lastTime = nowTime;
      return;
    }

    if (trailing && !timer) {
      timer = setTimeout(() => {
        fn.apply(this, args);
        timer = undefined;
        lastTime = !leading ? 0 : new Date().getTime();
      }, remainTime);
    }
  }

  _throttle.cancel = function () {
    timer && clearTimeout(timer);
    timer = undefined;
    lastTime = 0;
  };

  return _throttle;
}
```

## 二、深拷贝

- 之前的学习
  - 引用的赋值：指向同一个对象，相互之间会影响
  - 对象的浅拷贝：浅层的拷贝，内部引入对象时，仍然会互相影响
  - 对象的深拷贝：两个对象不再有任何关系，不会互相影响

### 2.1 JSON.parse

```js
const obj = {
  name: "why",
  friend: {
    name: "kobe",
  },
};

const info = JSON.parse(JSON.stringify(obj));
```

- 弊端：
  1. 无法对 `function`、`Symbol` 进行拷贝
  2. 不支持循环引用 `obj.inner = obj`

### 2.2 自定义深拷贝函数

- 要求：
  1. 自定义深拷贝的基本功能
  2. 对 `Symbol` 的 `key` 进行处理
  3. 其他数据类型的值进行处理：数组、函数、`Symbol`、`Set`、`Map`
  4. 对循环引用的处理

#### 2.2.1 基本的深拷贝

```js
// 判断是否为对象类型
function isObject(value) {
  const valueType = typeof value;
  return value !== null && (valueType === "object" || valueType === "function");
}

function deepClone(originValue) {
  // 判断传入的 originValue 是否是一个对象类型
  if (!isObject(originValue)) {
    return originValue;
  }

  const newObject = {};

  for (const key in originValue) {
    newObject[key] = deepClone(originValue[key]);
  }

  return newObject;
}

const obj = {
  name: "why",
  age: 18,
  friend: {
    name: "james",
    address: {
      city: "广州",
    },
  },
};
const newObj = deepClone(obj);
```

#### 2.2.2 解决 其他类型拷贝错误 问题

```js
// 判断是否为对象类型
function isObject(value) {
  const valueType = typeof value;
  return value !== null && (valueType === "object" || valueType === "function");
}

function deepClone(originValue) {
  // 判断如果是 Symbol 的 value，那么创建一个新的 Symbol
  if (typeof originValue === "symbol") {
    return Symbol(originValue.description);
  }

  if (typeof originValue === "function") {
    // 如果是函数的话，直接返回原对象 ---- 函数本身就是为了复用才创造出来的
    return originValue;
  }

  // 判断传入的 originValue 是否是一个对象类型
  if (!isObject(originValue)) {
    return originValue;
  }

  // 判断传入的是 数组 还是 对象
  const newObject = Array.isArray(originValue) ? [] : {};

  for (const key in originValue) {
    newObject[key] = deepClone(originValue[key]);
  }

  return newObject;
}

/* 测试代码 */
let s1 = Symbol("aaa");
let s2 = Symbol("bbb");
const obj = {
  name: "why",
  age: 18,
  friend: {
    name: "james",
    address: {
      city: "广州",
    },
  },
  hobbies: ["abc", "cba", "nba"],
  foo: function () {
    console.log("foo function");
  },
  [s1]: "abc",
  s2: s2,
};
const newObj = deepClone(obj);
```
