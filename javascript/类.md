<!--
 * @Author: your name
 * @Date: 2021-10-23 12:45:31
 * @LastEditTime: 2021-10-23 16:32:44
 * @LastEditors: Please set LastEditors
 * @Description: 类
 * @FilePath: \知识点\类.md
-->

# 类 class ---- ES6

## 引入

1. 早期函数式编程 → 支持面向对象 by 原型
2. class 是之前继承写法的语法糖，仍要转为原型、原型链方式
3. 有些浏览器不支持 ES6
4. 某些框架为了适配更多的浏览器，不使用 class

## 类的构造函数

```js
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}

const p1 = new Person("why", 18);
const p2 = new Person("code", 20);
```

1. 类的声明与构造函数是分开的
2. 一个类只能有一个构造函数
3. 构造函数创建对象的过程
   1. 在内存中创建一个对象
   2. 将类的原型 prototype 赋值给创建出来的对象的\[\[prototype]]属性
   3. 将对象赋值给函数的 this
   4. 执行函数体中的代码
   5. 自动返回创建出来的对象

### 类的方法

```js
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  eating() {
    console.log(this..name + ' is eating~')
  }
  running() {
    console.log(this..name + ' is running~')
  }
}
```

1. 方法会被放到类的原型上

## 类的访问器方法与静态方法

```js
class Person {
  constructor(name, age, address) {
    this.name = name;
    this.age = age;
    this._address = address
  }

  eating() {
    console.log(this..name + ' is eating~')
  }
  running() {
    console.log(this..name + ' is running~')
  }

  // 访问器
  get address() {
    console.log('拦截访问操作')
    return this._address
  }
  set address(newValue) {
    console.log('拦截设置操作')
    this._address = newValue
  }

  // 静态方法 ---- Person类可以直接使用
  static randomPerson() {

  }
}
```

## 类的继承

```js
// 父类
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  eating() {
    console.log("eating");
  }

  running() {
    console.log("处理逻辑1");
    console.log("处理逻辑2");
  }
}

// 子类 or 派生类
class Student extends Person {
  constructor(name, age, sno) {
    super(name, age);
    this.sno = sno;
  }

  // 重写父类eating方法
  eating() {
    console.log("student eating");
  }

  // 重写父类running方法，并复用父类running方法
  running() {
    super.running();

    console.log("处理逻辑3");
    console.log("处理逻辑4");
  }
}
```

1. 在 \[访问 this] or \[return] 之前，必须通过 super 调用父类的构造方法
2. 可以通过 super 关键字复用父类方法 ---- 128 行 code
3. 父类的静态方法也可以被子类重写(同样可以使用 super 调用)

## ES6 转 ES5 代码 by Babel

1. babeljs.io 网站
2. 不允许以函数方式(`Person()`)调用 Person 类

   ```js
   class Person {}

   /** 转化成以下代码 */
   ("use strict");

   function _classCallCheck(instance, Constructor) {
     if (!(instance instanceof Constructor)) {
       throw new TypeError("Cannot call a class as a function");
     }
   }

   var Person = function Person() {
     _classCallCheck(this, Person);
   };
   ```

3. 使用

   ```js
   class Person {
     constructor(name, age) {
       this.name = name;
       this.age = age;
     }

     eating() {
       console.log(this.name + "is eating");
     }
   }

   /** 代码转化 */
   ("use strict");

   function _classCallCheck(instance, Constructor) {
     if (!(instance instanceof Constructor)) {
       throw new TypeError("Cannot call a class as a function");
     }
   }

   function _defineProperties(target, props) {
     for (var i = 0; i < props.length; i++) {
       var descriptor = props[i];
       descriptor.enumerable = descriptor.enumerable || false;
       descriptor.configurable = true;
       if ("value" in descriptor) descriptor.writable = true;
       Object.defineProperty(target, descriptor.key, descriptor);
     }
   }

   function _createClass(Constructor, protoProps, staticProps) {
     if (protoProps) _defineProperties(Constructor.prototype, protoProps);
     if (staticProps) _defineProperties(Constructor, staticProps);
     return Constructor;
   }

   // 立即执行函数：1. 避免变量名冲突；2. /*#__PURE__*/ 便于webpack tree-shaking压缩，没有副作用
   var Person = /*#__PURE__*/ (function () {
     function Person(name, age) {
       _classCallCheck(this, Person);

       this.name = name;
       this.age = age;
     }

     _createClass(Person, [
       {
         key: "eating",
         value: function eating() {
           console.log(this.name + "is eating");
         },
       },
     ]);

     return Person;
   })();
   ```

4. 带继承

   ```js
   class Person {
     constructor(name, age) {
       this.name = name;
       this.age = age;
     }

     eating() {
       console.log(this.name + "is eating");
     }
   }

   class Student extends Person {
     constructor(name, age, sno) {
       super(name, age);
       this.sno = sno;
     }

     studying() {
       console.log(this.name + " is studying");
     }
   }

   /** 转化代码 */
   ("use strict");

   function _typeof(obj) {
     "@babel/helpers - typeof";
     if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
       _typeof = function _typeof(obj) {
         return typeof obj;
       };
     } else {
       _typeof = function _typeof(obj) {
         return obj &&
           typeof Symbol === "function" &&
           obj.constructor === Symbol &&
           obj !== Symbol.prototype
           ? "symbol"
           : typeof obj;
       };
     }
     return _typeof(obj);
   }

   function _inherits(subClass, superClass) {
     // 边界判断：父类需要是一个函数 or null
     if (typeof superClass !== "function" && superClass !== null) {
       throw new TypeError(
         "Super expression must either be null or a function"
       );
     }
     subClass.prototype = Object.create(superClass && superClass.prototype, {
       constructor: { value: subClass, writable: true, configurable: true },
     });
     // 静态方法的继承 Student.__proto__ = Person
     if (superClass) _setPrototypeOf(subClass, superClass);
   }

   function _setPrototypeOf(o, p) {
     _setPrototypeOf =
       Object.setPrototypeOf ||
       function _setPrototypeOf(o, p) {
         o.__proto__ = p;
         return o;
       };
     return _setPrototypeOf(o, p);
   }

   function _createSuper(Derived) {
     var hasNativeReflectConstruct = _isNativeReflectConstruct();
     return function _createSuperInternal() {
       var Super = _getPrototypeOf(Derived),
         result;
       if (hasNativeReflectConstruct) {
         var NewTarget = _getPrototypeOf(this).constructor;
         result = Reflect.construct(Super, arguments, NewTarget); //Super -- Person, arguments -- ['why', 18], newTarget -- Student
         // 通过Person创建一个实例，但实例的原型指向Student
       } else {
         result = Super.apply(this, arguments);
       }
       return _possibleConstructorReturn(this, result);
     };
   }

   function _possibleConstructorReturn(self, call) {
     if (call && (_typeof(call) === "object" || typeof call === "function")) {
       return call;
     } else if (call !== void 0) {
       throw new TypeError(
         "Derived constructors may only return object or undefined"
       );
     }
     return _assertThisInitialized(self);
   }

   function _assertThisInitialized(self) {
     if (self === void 0) {
       throw new ReferenceError(
         "this hasn't been initialised - super() hasn't been called"
       );
     }
     return self;
   }

   function _isNativeReflectConstruct() {
     if (typeof Reflect === "undefined" || !Reflect.construct) return false;
     if (Reflect.construct.sham) return false;
     if (typeof Proxy === "function") return true;
     try {
       Boolean.prototype.valueOf.call(
         Reflect.construct(Boolean, [], function () {})
       );
       return true;
     } catch (e) {
       return false;
     }
   }

   function _getPrototypeOf(o) {
     _getPrototypeOf = Object.setPrototypeOf
       ? Object.getPrototypeOf
       : function _getPrototypeOf(o) {
           return o.__proto__ || Object.getPrototypeOf(o);
         };
     return _getPrototypeOf(o);
   }

   function _classCallCheck(instance, Constructor) {
     if (!(instance instanceof Constructor)) {
       throw new TypeError("Cannot call a class as a function");
     }
   }

   function _defineProperties(target, props) {
     for (var i = 0; i < props.length; i++) {
       var descriptor = props[i];
       descriptor.enumerable = descriptor.enumerable || false;
       descriptor.configurable = true;
       if ("value" in descriptor) descriptor.writable = true;
       Object.defineProperty(target, descriptor.key, descriptor);
     }
   }

   function _createClass(Constructor, protoProps, staticProps) {
     if (protoProps) _defineProperties(Constructor.prototype, protoProps);
     if (staticProps) _defineProperties(Constructor, staticProps);
     return Constructor;
   }

   var Person = /*#__PURE__*/ (function () {
     function Person(name, age) {
       _classCallCheck(this, Person);

       this.name = name;
       this.age = age;
     }

     _createClass(Person, [
       {
         key: "eating",
         value: function eating() {
           console.log(this.name + "is eating");
         },
       },
     ]);

     return Person;
   })();

   var Student = /*#__PURE__*/ (function (_Person) {
     _inherits(Student, _Person);

     var _super = _createSuper(Student);

     function Student(name, age, sno) {
       var _this;

       _classCallCheck(this, Student);

       _this = _super.call(this, name, age); // 创建出了Student对象 { name: 'why', age: 18 }
       _this.sno = sno;
       return _this;
     }

     _createClass(Student, [
       {
         key: "studying",
         value: function studying() {
           console.log(this.name + " is studying");
         },
       },
     ]);

     return Student;
   })(Person);

   // 读代码
   var stu = new Student("why", 18, 111);
   ```

## 创建一个类，继承自内置类

```js
class MyArray extends {
  firstItem() {
    return this[0]
  }
}

var arr = new MyArray(1, 2, 3)
console.log(arr.firstItem())
```

## 类的混入 mixin

> 没有专门的关键字，只是用技巧实现而已

```js
class Person {}

function mixinRunner(BaseClass) {
  class NewClass extends BaseClass {
    running() {}
  }

  return newClass;
}

class Student extends Person {}

var NewStudent = mixRunner(Student);
var stu = new NewStudent();
stu.running();

function mixinEater(BaseClass) {
  return class extends BaseClass {
    eating() {}
  };
}
```

1. js 中类只能有一个父类：单继承
