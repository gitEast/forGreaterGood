<!--
 * @Author: East
 * @Date: 2021-12-14 13:56:05
 * @LastEditTime: 2021-12-14 17:45:17
 * @LastEditors: Please set LastEditors
 * @Description: 项目实践十二
 * @FilePath: \forGreaterGood\vue3\42-项目实践十二.md
-->

# 项目实践十二

## 小问题解决

1. 时间问题，零时区 --> 东八区
   ```ts
   dayjs.utc(utcString).utcOffset(8).format(format);
   ```
2. 退出登录
   1. 删除保存在本地的 token
   2. 告诉服务器当前登录用户已退出(有的没有)
   3. 跳转到 login 页面(其实 push 到 main 也一样)
3. 对 getInitialDataAction 放到 login 的逻辑中
   ```ts
   // 设置 token 到 cache
   dispatch("getInitialDataAction", null, { root: true });
   ```

## role 页面

1. 用封装好的 组件 + hooks 完成增删改操作
2. 角色会分配菜单权限，开始正题

---

> 在原来 form 的封装之上，又需要再进行扩展
>
> > 要求：尽量不修改 form 与 中间层 的代码，尽量放到 role 页面中

1. 在 page-modal 放入一个默认插槽
2. 在 role 页面使用 el-tree(可选的)
   1. 全部的 menu 保存在 getInitialDataAction 中 entireMenu
   2. 拿到 menus，传入 el-tree
   3. 样式调一下
   4. otherInfo=ref<any>{}
3. 另外的数据传入
   1. 对 page-modal 传入属性 otherInfo，默认为空
   2. 对 新增 + 编辑 操作加入 otherInfo
   3. el-tree 的 变动 handleCheckChange(data1: any, data2: any){}, 选中节点，半选节点， menuList 中全都要
4. 编辑功能的权限选中回显

   1. 使用 editCallback 放进去
   2. setCheckKeys 方法：会出现问题，解决办法 -- 只对叶节点调用
   3. map-menus 中

      ```ts
      function menuMapLeafKeys(menuList: any[]) {
        const leftKeys: number[] = [];

        const _recurseGetLeaf = (menuList: any[]) => {
          menuList.forEach((item) => {
            // 如果 item.Children 就递归
            // 如果是，item.id 放入leftKeys
          });
        };
      }
      ```

   4. 对 editCallback 进行操作
      ```ts
      // 拿到 leafKeys
      // 此时 elTreeRef 还没绑定上去，
      // 使用 nextTick 解决
      nextTick(() => {
        elTreeRef.value?.setCheckedKeys(leafKeys, false);
      });
      ```
